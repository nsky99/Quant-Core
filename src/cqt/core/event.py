import asyncio
from enum import Enum
from typing import Optional, Dict, Any, List

# --- Event Base Class ---
class Event:
    """
    Base class for all events in the system.
    Each event has a 'type' attribute for easy identification.
    """
    @property
    def type(self) -> str:
        return self.__class__.__name__

# --- Market Data Events ---
class MarketEvent(Event):
    """
    Handles the event of receiving new market data (e.g., a new bar/kline).
    """
    def __init__(self,
                 symbol: str,
                 timeframe: Optional[str] = None,
                 data: Optional[Any] = None,
                 timestamp: Optional[int] = None):
        self.symbol = symbol
        self.timeframe = timeframe # e.g., '1m', '1h'
        self.data = data # Can be a pd.Series for a bar, a dict for a ticker, a list for trades
        self.timestamp = timestamp if timestamp is not None else (int(data['timestamp']) if isinstance(data, dict) and 'timestamp' in data else 0)

# --- Market Regime Events ---
class MarketRegime(Enum):
    """Defines the possible states of the market."""
    TRENDING_UP = "Trending Up"
    TRENDING_DOWN = "Trending Down"
    RANGING = "Ranging"
    UNDEFINED = "Undefined"

class RegimeChangeEvent(Event):
    """Generated when a market regime change is detected."""
    def __init__(self,
                 timestamp: int,
                 symbol: str,
                 timeframe: str,
                 regime: MarketRegime,
                 details: Optional[Dict] = None):
        self.timestamp = timestamp
        self.symbol = symbol
        self.timeframe = timeframe
        self.regime = regime
        self.details = details if details is not None else {}

    def __str__(self):
        return (f"Event: {self.type} | Symbol: {self.symbol} | Timeframe: {self.timeframe} | "
                f"New Regime: {self.regime.value}")

# --- Signal and Order Events ---
class SignalEvent(Event):
    """
    Handles the event of a Strategy generating a signal (e.g., LONG, SHORT, EXIT).
    This is an intermediate step before an order is placed.
    """
    def __init__(self,
                 strategy_name: str,
                 symbol: str,
                 side: str, # 'buy' or 'sell'
                 strength: float = 1.0): # e.g., a value from 0 to 1 indicating confidence
        self.strategy_name = strategy_name
        self.symbol = symbol
        self.side = side
        self.strength = strength

class OrderRequestEvent(Event):
    """
    Handles the request to place an order on the exchange.
    Generated by the Portfolio/RiskManager after evaluating a SignalEvent.
    """
    def __init__(self,
                 symbol: str,
                 side: str,
                 order_type: str, # 'market' or 'limit'
                 quantity: float,
                 price: Optional[float] = None,
                 strategy_name: Optional[str] = None):
        self.symbol = symbol
        self.side = side
        self.order_type = order_type
        self.quantity = quantity
        self.price = price
        self.strategy_name = strategy_name

class OrderUpdateEvent(Event):
    """
    Represents an update to an order's state from the exchange.
    Wraps the raw order data from the exchange.
    """
    def __init__(self, order_data: Dict):
        self.order_data = order_data # The full order dictionary from ccxt

class FillEvent(Event):
    """
    Represents a trade that has been executed (a fill).
    This is generated from an OrderUpdateEvent when an order is filled or partially filled.
    """
    def __init__(self,
                 timestamp: int,
                 strategy_name: str,
                 symbol: str,
                 side: str,
                 filled_qty: float,
                 avg_fill_price: float,
                 fee: float,
                 fee_currency: str,
                 order_id: str,
                 client_order_id: Optional[str] = None):
        self.timestamp = timestamp
        self.strategy_name = strategy_name
        self.symbol = symbol
        self.side = side
        self.filled_qty = filled_qty
        self.avg_fill_price = avg_fill_price
        self.fee = fee
        self.fee_currency = fee_currency
        self.order_id = order_id
        self.client_order_id = client_order_id


# --- Event Bus ---
class EventBus:
    """
    A simple asynchronous event bus using asyncio.Queue.
    """
    def __init__(self, name: str = "EventBus"):
        self._queue = asyncio.Queue()
        self.name = name

    async def put(self, event: Event):
        """
        Put an event into the bus.
        """
        await self._queue.put(event)

    async def get(self) -> Event:
        """
        Get an event from the bus. Blocks until an event is available.
        """
        return await self._queue.get()

    def task_done(self):
        """
        Signal that a formerly enqueued task is complete.
        Used for queue management.
        """
        self._queue.task_done()

    async def join(self):
        """
        Block until all items in the queue have been received and processed.
        """
        await self._queue.join()

    def empty(self) -> bool:
        """
        Check if the event bus is empty.
        """
        return self._queue.empty()
